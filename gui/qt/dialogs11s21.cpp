#include "dialogs11s21.h"
#include "ui_dialogs11s21.h"

dialogS11S21::dialogS11S21(QWidget *parent) :
  QDialog(parent),
  ui(new Ui::dialogS11S21)
{
  ui->setupUi(this);
}

dialogS11S21::~dialogS11S21()
{
  delete ui;
}
//ver115-5d added S11ToS21
void dialogS11S21::S11ToS21()
{/*//Convert current S11 data to S21 in either Series or Shunt Fixture
    //Results are put into auxGraphData(x,0) and auxGraphData(x,1) for each step x, representing
    //S21 mag and phase. They are set as the current graph data and are listed as an additional graph type
    //until the next Restart.

    WindowWidth = 570
    WindowHeight = 275
    call GetDialogPlacement
    BackgroundColor$="gray"
    ForegroundColor$="black"
    TextboxColor$ = "white"

    statictext #S11S21.title, "CONVERT S11 TO S21 IN SHUNT OR SERIES FIXTURE",70, 10, 375, 20
    s$="This function determines the S21 values that would generated by a device with the impedances"
    s$=s$;" indicated by the current S11 values. That S21 can be generated for either the shunt or"
    s$=s$;" series fixture. Plane extension is not included in the calculated S21 values."
    statictext #S11S21.title1, s$,20, 30, 540, 60

    controlTop=95
    checkbox #S11S21.series, "Series Fixture", void dialogS11S21::S11S21Series(), void dialogS11S21::S11S21Series(), 10, controlTop, 400,20
    checkbox #S11S21.shunt, "Shunt Fixture", void dialogS11S21::S11S21Shunt(), void dialogS11S21::S11S21Shunt(), 10, controlTop+25, 400,20
    statictext #S11S21, "Fixture R0", 10, controlTop+52, 60, 16
    textbox #S11S21.R0, 72, controlTop+50, 50, 20
    button #S11S21.convert, "Generate S21", void dialogS11S21::S11S21Generate(), UL,100,controlTop+100, 100, 25
    button #S11S21.help, "Help", S11ToS21Help, UL,300,controlTop+100, 100, 25

        //Open dialog
    open "Convert S11 to S21" for dialog_modal as #S11S21

    #S11S21, "trapclose void dialogS11S21::S11S21Cancel()"
    #S11S21, "font ms_sans_serif 10"
    #S11S21.R0, S11GraphR0  //Assume we will keep same R0
    goto void dialogS11S21::S11S21Series()
*/
}
void dialogS11S21::S11S21Cancel()
{/*
    close #S11S21
    exit sub
*/
}
void dialogS11S21::S11S21Series()
{/*
    #S11S21.series, "set" : #S11S21.shunt, "reset"
    wait
*/
}
void dialogS11S21::S11S21Shunt()
{/*    #S11S21.series, "reset" : #S11S21.shunt, "set"
    wait
*/
}
void dialogS11S21::S11S21Generate()
{/*    #S11S21.series, "hide" : #S11S21.shunt, "hide"
    #S11S21.convert, "!hide" : #S11S21.help, "!hide"
    #S11S21.R0, "!contents? R0$"
    conversionR0=uValWithMult(R0$)  //reference R0 for S21
    if conversionR0<=0 then notice "Invalid Fixture R0" : wait  //error
    call ClearAuxData   //Clear auxiliary graph data by blanking graph names
    call gGetMinMaxPointNum pMin, pMax
    if pMin<1 or pMax<pMin then goto void dialogS11S21::S11S21Cancel() //No points to process
    #S11S21.series, "value? S11S21SeriesVal$"
    for currStep=pMin-1 to pMax-1  //Step number is one less than point num
        //If R0 is unchanged, we have specific routines to convert S11 to S21. Otherwise, first convert to impedance
        //and then to S21.
        if conversionR0<>S11GraphR0 then
            call CalcGraphDataType currStep, constSerR, constSerReact, serR, serX, 0 //Get current impedance for this step from scan data
        else
            call CalcGraphDataType currStep, constRho, constTheta, rho, theta, 0 //Get current S11 for this step from scan data
        end if
        if S11S21SeriesVal$="set" then
            if conversionR0=S11GraphR0 then
                call uRefcoToSeriesS21DB rho, theta, S21DB, S21Ang  //S21 for refco in series fixture
            else
                call uSeriesImpedanceToS21DB conversionR0, serR, serX, S21DB, S21Ang    //S21 for impedance in series fixture
            end if
        else    //Note we assume no delay; we could use the current shunt fixture delay
            if conversionR0=S11GraphR0 then
                call uRefcoToShuntS21DB rho, theta, S21DB, S21Ang  //S21 for refco in shunt fixture //ver116-4k
            else
                call uShuntImpedanceToS21DB conversionR0, serR, serX, 0, 0, S21DB, S21Ang    //S21 for impedance in shunt fixture, w/o delay
            end if
        end if
        auxGraphData(currStep,0)=S21DB  //S21DB
        auxGraphData(currStep,1)=S21Ang  //S21Ang
    next currStep

    //We must now describe the data in auxGraphData for the graphing routines
        //S21 Mag
    R0$=uFormatted$(conversionR0, "3,2,3//UseMultiplier//DoCompact")    //Print conversion R0 as part of graph name and axis heading
    S21Lab$="S21(";R0$;") "
    auxGraphDataFormatInfo$(0,0)=S21Lab$;"dB" : auxGraphDataFormatInfo$(0,1)="####.###//DoCompact"  //Graph name; format string
    auxGraphDataFormatInfo$(0,2)=S21Lab$;"dB": auxGraphDataFormatInfo$(0,3)="S21 dB"    //Axis heading; marker label
    auxGraphDataInfo(0,0)=0 //not an angle
    auxGraphDataInfo(0,1)=-100 //axis min
    auxGraphDataInfo(0,2)=0  //axis max
        //S21 Angle
    auxGraphDataFormatInfo$(1,0)=S21Lab$;"Deg" : auxGraphDataFormatInfo$(1,1)="####.##//DoCompact"
    auxGraphDataFormatInfo$(1,2)=S21Lab$;"Deg": auxGraphDataFormatInfo$(1,3)="S21 Deg"
    auxGraphDataInfo(1,0)=1 //is an angle
    auxGraphDataInfo(1,1)=-180 //axis min
    auxGraphDataInfo(1,2)=180  //axis max

        //Db will go on primary axis
    if primaryAxisNum=1 then    //ver115-5f
        call ChangeGraphsToAuxData constAux0, constAux1 //S21 Mag on left, angle on right
    else
        call ChangeGraphsToAuxData constAux1, constAux0 //S21 angle on left, db on right
    end if

    goto void dialogS11S21::S11S21Cancel() //quit once we convert
end sub
*/
}
void dialogS11S21::S11ToS21Help(QString h)
{/*    WindowWidth = 550
    WindowHeight = 370
    call GetDialogPlacement
    BackgroundColor$="gray"
    ForegroundColor$="black"

    s$="The scanned S11 values (whether or not they are currently graphed) represent impedances that can be"
    s$=s$;" hypothetically placed in a Series Fixture (with the TG signal run through the DUT to the MSA input)"
    s$=s$;" or in a Shunt Fixture (with the TG signal run directly to the MSA input via a line to which the"
    s$=s$;" DUT is attached, with the other DUT terminal grounded). The fixture can have whatever R0 value the"
    s$=s$;" user specifies, typically 50 ohms."
    statictext #S11S21Explain, s$, 10, 10, 520, 85

    s$="This concept only makes sense for devices that have exactly two terminals, such as resistors, capacitors,"
    s$=s$;" inductors, crystals, or simple parallel or series RLC combinations, or for devices with one terminal"
    s$=s$;" plus an explicit or implicit ground, such as an antenna. It does not make sense for amplifiers, which"
    s$=s$;" have three terminals--input, output and ground. In addition, devices with a permanent or implicit"
    s$=s$;" ground cannot be made floating, and therefore it makes no sense to generate their S21 in a series fixture."
    statictext #S11S21Explain, s$, 10, 105, 515, 100

    s$="If you have specified a plane extension value, it was taken into account in calculating S11, but it is not"
    s$=s$;" taken into account for the conversion to S21. That is, there is no plane extension (or other connector"
    s$=s$;" delay) in the hypothetical S21 fixture."
    statictext #S11S21Explain, s$, 10, 215, 515,  50

    s$="When you click Generate S21, two new graph types will be created and displayed, for the generated S21 dB and angle"
    s$=s$;" values. They will also be available in the list of graph types in the Y-axis windows until Restart."
    statictext #S11S21Explain, s$, 10, 275, 515,  50

    open "Generate S21 Help" for dialog_modal as #S11S21Explain
    print #S11S21Explain, "font ms_sans_serif 10"
    print #S11S21Explain, "trapclose void dialogS11S21::S11S21ExplainEnd()"

    wait
*/
}
void dialogS11S21::S11S21ExplainEnd()
{/*    close #S11S21Explain
    exit sub

end sub //end S11ToS21Help
*/
}

//ver116-4h deleted LossyImpedToParallelLC
